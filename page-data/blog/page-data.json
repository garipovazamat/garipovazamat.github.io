{"componentChunkName":"component---src-pages-blog-js","path":"/blog/","result":{"data":{"allStrapiArticle":{"edges":[{"node":{"id":"Article_3","title":"Создание блога на GatsbyJs и strapi","content":"  Этот сайт я создавал при помощи фреймворка GatsbyJs. Это один из статических генераторов сайтов. Общая концепция статических генераторов сайта такова:\n- Сначала локально создаем страницы сайта и указываем источники данных, откуда будут браться статьи и другие ресурсы, это могут быть локальные файла, база данных, сторонее API и т.д. \n- На наших страницах указываем как данные будут отображаться и как их нужно обработать.\n- Запускаем сборку сайта, наш фреймворк выгружает все необходимые данные и сохраняет их в сборке нашего проекта.\n- Затем эту сборку можно разместить на хостинге файлов, и для него **не нужны сторонние источники данных, потому что при сборке уже все выгруженно**.\n- Сам фреймворк GatsbyJs основан на библиотеке ReactJs. Для тех кто знаком с ReactJs разобраться будет намного проще. \n\n### Разворачиваем проект\nУстанавливаем npm если его у вас ещё нет (это пакетный менеджер для nodejs). Фреймворк на js, поэтому для разработки и сборки проекта используется nodeJs.  \nCтавим gatsby-cli в системе командой \n```\nnpm install -g gatsby-cli\n```\nИ затем разворачиваем папку с проектом, переходим в неё и запускаем сервер для режима разработки\n\n```\ngatsby new gatsby-site\ncd gatsby-site\ngatsby develop\n```\nДокументация по установке проекта [тут](https://www.gatsbyjs.org/tutorial/part-zero/)\n\nПроект развернут, можно переходить к структуре папок и коду.  \nКонфиги проекта находятся в файле gatsby-config.js в корневой папке проекта. Здесь указываются метаданные сайта и источники данных для сайта. Доступ к разным источникам дается через различные плагины. Эти плагины дают нам возможность обращаться к источнику через язык запросов GraphQL. Например в проекте по умолчанию установлен плагин gatsby-source-filesystem, он позволяет получать доступ к списку файлов и самим файлам в проекте через GraphQl простым запросом.  \nВ этом блоге в качестве CMS я применил Strapi. Для доступа к данным в Strapi я использовал плагин gatsby-source-strapi.  \nПрежде чем настраивать доступ к файлам я покажу как я установил и настроил Strapi.\n\n### Установка Strapi\nStrapi это CMS которая позволяет создавать свои сущности (например статьи) через простой графический конструктор указывая какие поля и связи у нее есть. Затем создавать записи для этих сущностей, и получать данные по ним через Api, либо запросом по GraphQL. Продукт бесплатный и на данный момент активно развивается.  \nНа момент создания блога ещё не была готова релизная версия, поэтому я устанавливал версию 3-0-0-beta. Она устанавливается очень быстро, по умолчанию использует базу данных SQLite, но можно использовать и любую популярную базу вместо нее. Как устанавливать написано в официальных доках [установка strapi](https://strapi.io/documentation/3.0.0-beta.x/getting-started/quick-start.html#_1-install-strapi-and-create-a-new-project) .  \nУстановив и развернув у себя локально сервер strapi по официальной инструкции, заходим на http://localhost:1337/admin и регистрируемся. Затем нужно создать новую сущность через \"Конструктор типов контента\". Нужно сущность *article* и для нее создать поля:\n- *title* - заголовок статьи \n- *content* - тут будет содержимое статьи в формате **markdown** \n- *description* - краткое описание статьи, оно будет отображаться в списке статей\n- *url_path* - путь в ссылке на статью, будет идти после /blog/{тут это название}\n- и поле типа \"связь\" со связями много статей к одному *user*\n\nТакже нужно настроить права доступа к новой сущности на чтение и получение количества для всех пользователей. Это делается в \"Роли и доступы -> Public -> Доступы\" для *Article* проставить галочки в *count*, *find*. \n![Доступы в strapi](https://avatars.mds.yandex.net/get-pdb/2838007/6f8efe15-ce54-403e-88b3-f78dbd5cf886/s1200)\nТеперь можно писать статьи, и они будут доступны по адресу http://localhost:1337/articles\n\n### Пишем код проекта\nУстанавливаем плагин для доступа к данным в Strapi\n```\nnpm install --save gatsby-source-strapi\n```\nЗатем указываем в конфиге доступ к статьям. Добавляем в массив plugins объект\n```\n{\n      resolve: `gatsby-source-strapi`,\n      options: {\n        apiURL: `http://localhost:1337`,\n        queryLimit: 100\n        contentTypes: [`article`, `user`],\n      },\n    },\n```\nСделав это мы получаем доступ через GraphQL в наших компонентах на получение данных из strapi.\n\n#### Создание страницы со списком статей\nСтраница со списком статей будет расположена по ссылке /blog/ и файл в котором написан код страницы в *src/pages/blog.js* относительно корня проекта.  \n> Почему файлы лежащие в *src/pages/* соответствуют пути / в браузере спросите вы. Дело в том, что в сам фреймворк зашито такое поведение. И это один из недостатков фреймворков, по моему мнению. То что файлы для корневого пути лежат именно в этой папке никак не указано явно в конфигах, и новичку с первого раза становится непонятно, как пути привязаны к папке.  \nМожно создавать компоненты страниц не привязываясь к папке src/pages/, но об этом я напишу ниже, когда буду создавать отдельную страницу статьи.  \n\nЕщё нужно установить библиотеку для преобразования Markdown разметки в html, поскольку статьи хранятся в формате Markdown в Strapi, и через апи они приходят тоже в этом формате.\n```\nnpm install --save react-markdown\n```\n\nНиже я привел часть кода из файла *src/pages/blog.js*. Описание по коду читайте в самом коде\n```\nimport React from \"react\"\nimport { Link } from \"gatsby\"\nimport Layout from \"../components/layout\"\nimport SEO from \"../components/seo\"\n\n// Компонент для преобразования в Markdown\nimport ReactMarkdown from \"react-markdown\"\n\nconst Blog = ({data}) => (\n  <Layout>\n    <SEO title=\"Блог\" />\n    <ul>\n      //Данные получены через запрос GraphQL\n      {data.allStrapiArticle.edges.map(document => (\n        <li key={document.node.id}>\n          <h2>\n            // Тут формируются ссылки на отдельные статьи из поля url_path\n            <Link to={`/blog/${document.node.url_path}`}>{document.node.title}</Link>\n          </h2>\n          // Отображаем нашу статью через Markdown компонент\n          <p><ReactMarkdown source={document.node.description} /></p>\n        </li>\n      ))}\n    </ul>\n  </Layout >\n)\n\nexport default Blog\n```\nLayout - это компонент, общий для многих страниц, отображающий шапку и футер страниц. Я его переделал, но не стал акцентировать внимание на ней в этой статье.  \nДалее в этот же файл нужно добавить сам запрос GraphQL, полученные данные прокинутся в объект *data* в компоненте страницы Blog\n\nДалее в тот же файл добавляем следующий кусок кода:\n```\nexport const pageQuery = graphql`\nquery BlogQuery {\n  allStrapiArticle {\n    edges {\n      node {\n        id\n        title\n        content\n        created_at\n        description\n        url_path\n      }\n    }\n  }\n}\n`\n```\nЭто сам запрос. Вы можете собрать свой запрос и тестировать его в специальном инструменте фреймворка, доступного по ссылке http://localhost:8000/___graphql\n\nКогда страница рисуется фреймворком, он ищет в этом файле любые экспортируемые graphql строки, делает запрос по нему и отправляет полученные данные через переменную *data* в компонент Blog. Константе содержащей graphql строку не обязательно называться *pageQuery*, главное чтобы это была экспортируемая строка типа graphql.  \n> На мой взгляд это ещё один недостаток фреймворка. Данные неявно прокидываются в компонент через некую магию, и на первый взгляд по коду не понятно, как запрос в graphql связан с данными в переменной *data*. Было бы лучше, если бы существовала общий конфиг с запросами, и в нем мы бы указывали какой запрос в какой компонент передается.\n\n#### Создание страницы с отдельной статьей\nТеперь создадим компонент, который будет отвечать за отображение отдельной статьи. Создадим файл src/components/article.js относительно корня проекта. Ниже его содержимое:\n```\nimport React from 'react'\nimport { graphql } from 'gatsby'\nimport ReactMarkdown from \"react-markdown\"\nimport Layout from '../components/layout'\n\nconst ArticleTemplate = ({ data }) => (\n  <Layout>\n    <h1>{data.strapiArticle.title}</h1>\n    <ReactMarkdown source={data.strapiArticle.content} />\n  </Layout>\n)\n\nexport default ArticleTemplate\nexport const query = graphql`\n  // Этот id приходит из конфига который расмотрим ниже\n  query ArticleTemplate($id: String!) {\n    strapiArticle(id: {eq: $id}) {\n      title\n      content\n    }\n  }\n`\n```\nЗдесь мы делаем тоже самое, что и при отображении списка статей, только мы пишем запрос на отдельную статью, и отображаем содержимое поля content, а не description. Параметр id в запросе graphql приходит из конфига, указанного в файле *gatsby-node.js*. В нем мы указываем следующее:\n```\nconst path = require(`path`);\n\nconst makeRequest = (graphql, request) => new Promise((resolve, reject) => {\n  // Query for nodes to use in creating pages.\n  resolve(\n    graphql(request).then(result => {\n      if (result.errors) {\n        reject(result.errors)\n      }\n\n      return result;\n    })\n  )\n});\n\nexports.createPages = ({ actions, graphql }) => {\n  const { createPage } = actions;\n   // ниже основной код\n  const getArticles = makeRequest(graphql, `\n    {\n      allStrapiArticle {\n        edges {\n          node {\n            id\n            url_path\n          }\n        }\n      }\n    }\n    `).then(result => {\n\n    result.data.allStrapiArticle.edges.forEach(({ node }) => {\n      createPage({\n        path: `/blog/${node.url_path}`,\n        component: path.resolve(`src/components/article.js`),\n        context: {\n          id: node.id,\n        },\n      })\n    })\n  });\n\n  return getArticles;\n};\n```\nВсе что написанно в этом файле, происходит во время сборки сайта. В этом файле мы пишем, что при сборке должны сходить в strapi, получить id и ссылки на статьи,  и имея эти данные указать в конфигах, что по полученным url нужно создавать страницы через компонент src/components/article.js и передать в этот компонент id статьи. В самом же компоненте по id будет получено содержимое статьи и прорисованно как нам нужно. Подробнее о том как это работает можете почитать здесь: https://www.gatsbyjs.org/docs/actions/#createPage\n\n### Выводы\nСреди **плюсов** фреймворка GatsbyJs хочу отметить наличие большого количества плагинов и наличие хорошей документация. Ещё один из плюсов - она основана на библиотеке ReactJs, это позволяет делать крутые вещи на js сильно экономя время людям, имеющим опыт работы с этой библиотекой.  \nФреймворк позволяет очень легко работать с любым источником данных, просто применив подходящий для этого источника плагин, и работать с источником через graphQL.  \n  **Минусы**: много неявных связей в коде. Многие настройки зашиты в сам фреймворк, и даже для достаточно простых вещей трудно найти причину такого поведения, т.е. фреймворк не такой интуитивный как хотелось бы. Но это компенсируется удобной документация, нужные вопросы легко найти на официальном сайте.  \nStrapi ещё сыроват для серьезной разработки, но очень перспективен, если посмотреть на официальном сайте их RoadMap, то там планируются интересные вещи [сссылка на RoadMap](https://portal.productboard.com/strapi/1-public-roadmap/tabs/3-planned)  \n \nИсточники:\n- https://www.gatsbyjs.org/docs/  \n- https://strapi.io/documentation/3.0.0-beta.x/getting-started/introduction.html  \n- https://github.com/strapi/gatsby-source-strapi  \n","updated_at":"2020-01-10T17:08:26.962Z","description":"Первую статью этого блога я начну с того, как создавался сам этот блог. Я использовал фреймворк GatsbyJs и систему управления контентом Strapi. \nТакже расскажу с какими проблемами столкнулся, и какие недостатки фреймворка заметил.","url_path":"gatsby_strapi_blog"}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}}